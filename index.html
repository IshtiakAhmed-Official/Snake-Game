<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- MODERN CSS START --- */
        :root {
            --bg-gradient-start: #f4f7f6;
            --bg-gradient-end: #dce3e1;
            --text-color: #333;
            --text-light: #555;
            --primary-color: #007bff; /* High Score */
            --secondary-color: #28a745; /* Score */
            --danger-color: #dc3545; /* Game Over */
            --surface-color: #ffffff;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --font-main: 'Poppins', sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-main);
            background-image: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            padding: 2rem 1rem;
        }

        h1 {
            color: var(--text-color);
            font-weight: 700;
            font-size: 2.5rem;
            margin-bottom: 1.5rem;
            text-shadow: 1px 1px 2px var(--shadow-color);
        }

        #score-container {
            display: flex;
            justify-content: space-between;
            width: 100vmin;
            max-width: 1000px;
            margin-bottom: 15px;
            font-size: 1.5rem;
            font-weight: 600;
        }

        #score-board {
            color: var(--secondary-color);
        }

        #high-score-board {
            color: var(--primary-color);
        }

        #game-container {
            background-color: var(--surface-color);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05), 0 10px 30px rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            overflow: hidden;
            width: 100vmin;
            max-width: 1000px;
            aspect-ratio: 16 / 9;
            position: relative; 
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #game-over-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.75);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.18);
            box-shadow: 0 8px 32px 0 var(--shadow-color);
            padding: 25px 45px;
            border-radius: 15px;
            font-size: 2.25rem;
            color: var(--danger-color);
            font-weight: 700;
            text-align: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s ease;
        }
        
         #game-over-message span {
            font-size: 1.2rem;
            color: var(--text-light);
            font-weight: 400;
            display: block;
            margin-top: 10px;
         }
        /* --- MODERN CSS END --- */
    </style>
</head>
<body>

    <h1>Classic Snake Game</h1>

    <div id="score-container">
        <div id="score-board">Score: 0</div>
        <div id="high-score-board">High Score: 0</div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas" width="640" height="360"></canvas>
            
        <div id="game-over-message">
            Game Over!
            <span>Press 'R' to Restart</span>
        </div>
    </div>
    
    <script>
        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreBoard = document.getElementById('score-board');
        const highScoreBoard = document.getElementById('high-score-board');
        const gameOverMessage = document.getElementById('game-over-message');

        // Game constants
        const gridSize = 20;
        
        // --- Obstacle Constants ---
        const OBSTACLE_LIFETIME_TICKS = 100; // How long each 'rock' lasts
        const OBSTACLE_SPAWN_TICKS = 30;   // How often the game TRIES to spawn a 'rock'
        const MAX_OBSTACLES = 5;           // Max 'rock' obstacles on screen at once
        
        const tileCountX = canvas.width / gridSize;
        const tileCountY = canvas.height / gridSize;

        // --- Game State ---
        let snake = [
            { x: 16, y: 9 }
        ];
        
        // An array of {x, y, lifetime, type: 'rock' | 'decoy'}
        let obstacles = []; 
        let spawnTimer = OBSTACLE_SPAWN_TICKS; // Timer for new 'rock' spawns

        let food = getRandomFoodPosition(); // Now this function can safely access `obstacles`

        let direction = { x: 0, y: 0 };
        let score = 0;
        let highScore = 0; 
        let gameSpeed = 150;
        let isGameOver = false;
        let isGameRunning = false;
        let gameLoopTimeout;

        // --- High Score Functions ---
        function loadHighScore() {
            const savedHighScore = localStorage.getItem('snakeHighScore');
            if (savedHighScore) {
                highScore = parseInt(savedHighScore, 10);
            }
            highScoreBoard.textContent = `High Score: ${highScore}`;
        }

        function saveHighScore() {
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snakeHighScore', highScore);
                highScoreBoard.textContent = `High Score: ${highScore}`;
            }
        }

        // --- Game Logic ---
        function gameLoop() {
            if (isGameOver || !isGameRunning) {
                return;
            }
            update();
            draw();
            clearTimeout(gameLoopTimeout);
            gameLoopTimeout = setTimeout(gameLoop, gameSpeed);
        }

        function update() {
            const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

            // Check for wall collision
            if (head.x < 0 || head.x >= tileCountX || head.y < 0 || head.y >= tileCountY) {
                gameOver();
                return;
            }

            // Check for self-collision
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    gameOver();
                    return;
                }
            }

            // Check for obstacle collision (Rocks and Decoys)
            for (const obs of obstacles) {
                if (head.x === obs.x && head.y === obs.y) {
                    gameOver();
                    return;
                }
            }

            snake.unshift(head);

            // Check for food collision
            if (head.x === food.x && head.y === food.y) {
                score++;
                scoreBoard.textContent = `Score: ${score}`;
                
                food = getRandomFoodPosition();
                
                // --- MODIFIED LOGIC ---
                // When score is a multiple of 10, ADD a new decoy.
                // We NO LONGER clear the old one.
                if ((score+1) % 5 === 0) {
                    // clearDecoyObstacle(); // <-- This line is removed
                    spawnDecoyObstacle(); // Just spawn the new one
                }
                // --- END MODIFIED LOGIC ---
                
                if (score <= 7 && gameSpeed > 50) {
                    gameSpeed -= 5;
                }
            } else {
                snake.pop();
            }

            // --- 'Rock' Obstacle Timer Logic ---
            
            // 1. Update lifetimes and remove old 'rock' obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                // Only count down lifetime for 'rock' obstacles
                if (obstacles[i].type === 'rock') {
                     obstacles[i].lifetime--;
                    if (obstacles[i].lifetime <= 0) {
                        obstacles.splice(i, 1); // Remove this 'rock'
                    }
                }
            }

            // 2. Spawn new 'rock' obstacles
            spawnTimer--;
            if (spawnTimer <= 0) {
                spawnTimer = OBSTACLE_SPAWN_TICKS; // Reset spawn timer

                // Count current 'rock' obstacles
                const rockCount = obstacles.filter(obs => obs.type === 'rock').length;

                // Only spawn if we are under the 'rock' cap
                if (rockCount < MAX_OBSTACLES) {
                    const newPos = getRandomObstaclePosition();
                    obstacles.push({
                        x: newPos.x,
                        y: newPos.y,
                        lifetime: OBSTACLE_LIFETIME_TICKS,
                        type: 'rock' // Specify the type
                    });
                }
            }
        }

        function draw() {
            // Draw grass background
            for (let x = 0; x < tileCountX; x++) {
                for (let y = 0; y < tileCountY; y++) {
                    const shadeFactor = (x % 2) === (y % 2) ? 0.9 : 1.0;
                    const baseGreen = 170;
                    const green = Math.floor(baseGreen * shadeFactor + (Math.random() * 20 - 10));
                    ctx.fillStyle = `rgb(170, ${green}, 187)`;
                    ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
                }
            }

            // Draw Grid
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let x = gridSize; x < canvas.width; x += gridSize) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            ctx.stroke();
            ctx.beginPath();
            for (let y = gridSize; y < canvas.height; y += gridSize) {
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            ctx.stroke();

            // --- Draw All Obstacles (Rocks and Decoys) ---
            for (const obs of obstacles) {
                if (obs.type === 'decoy') {
                    // --- Draw DECOY (as food) ---
                    const foodRadius = gridSize / 2.2;
                    const foodX = obs.x * gridSize + gridSize / 2;
                    const foodY = obs.y * gridSize + gridSize / 2;
                    ctx.beginPath();
                    ctx.arc(foodX, foodY, foodRadius, 0, 2 * Math.PI);
                    
                    // --- THIS IS THE CHANGED LINE ---
                    ctx.fillStyle = '#db605c'; // light color for decoy
                    // --- END OF CHANGE ---

                    ctx.fill();
                    
                    // Draw stem
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(foodX, foodY - foodRadius / 2);
                    ctx.lineTo(foodX + 2, foodY - foodRadius);
                    ctx.stroke();
                    ctx.lineWidth = 1;

                } else {
                    // --- Draw ROCK (original code) ---
                    const obstacleX = obs.x * gridSize;
                    const obstacleY = obs.y * gridSize;

                    ctx.fillStyle = '#666777'; // Dark rock color
                    ctx.fillRect(obstacleX, obstacleY, gridSize, gridSize);
                    ctx.strokeStyle = '#333333'; // Dark border
                    ctx.strokeRect(obstacleX, obstacleY, gridSize, gridSize);
                }
            }

            // Draw Food (Apple)
            const foodRadius = gridSize / 2.2;
            const foodX = food.x * gridSize + gridSize / 2;
            const foodY = food.y * gridSize + gridSize / 2;
            ctx.beginPath();
            ctx.arc(foodX, foodY, foodRadius, 0, 2 * Math.PI);
            ctx.fillStyle = '#d9534f'; // This is the REAL food color (red)
            ctx.fill();
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(foodX, foodY - foodRadius / 2);
            ctx.lineTo(foodX + 2, foodY - foodRadius);
            ctx.stroke();
            ctx.lineWidth = 1;

            // Draw Snake
            snake.forEach((segment, index) => {
                const segmentX = segment.x * gridSize;
                const segmentY = segment.y * gridSize;

                const gradient = ctx.createRadialGradient(
                    segmentX + gridSize / 2, segmentY + gridSize / 2, gridSize / 10,
                    segmentX + gridSize / 2, segmentY + gridSize / 2, gridSize / 1.5
                );
                gradient.addColorStop(0, '#80f080');
                gradient.addColorStop(1, '#4cae4c');
                ctx.fillStyle = gradient;
                ctx.fillRect(segmentX, segmentY, gridSize, gridSize);
                
                ctx.strokeStyle = '#3b8b3b';
                ctx.strokeRect(segmentX, segmentY, gridSize, gridSize);

                // Draw Eyes
                if (index === 0) {
                    ctx.fillStyle = '#000000';
                    const eyeSize = gridSize / 5;
                    const eyeOffset1 = gridSize / 4;
                    const eyeOffset2 = gridSize - eyeOffset1;

                    if (direction.x === 1) { // Right
                        ctx.beginPath();
                        ctx.arc(segmentX + eyeOffset2, segmentY + eyeOffset1, eyeSize, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(segmentX + eyeOffset2, segmentY + eyeOffset2, eyeSize, 0, 2 * Math.PI);
                        ctx.fill();
                    } else if (direction.x === -1) { // Left
                        ctx.beginPath();
                        ctx.arc(segmentX + eyeOffset1, segmentY + eyeOffset1, eyeSize, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(segmentX + eyeOffset1, segmentY + eyeOffset2, eyeSize, 0, 2 * Math.PI);
                        ctx.fill();
                    } else if (direction.y === 1) { // Down
                        ctx.beginPath();
                        ctx.arc(segmentX + eyeOffset1, segmentY + eyeOffset2, eyeSize, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(segmentX + eyeOffset2, segmentY + eyeOffset2, eyeSize, 0, 2 * Math.PI);
                        ctx.fill();
                    } else if (direction.y === -1) { // Up
                        ctx.beginPath();
                        ctx.arc(segmentX + eyeOffset1, segmentY + eyeOffset1, eyeSize, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(segmentX + eyeOffset2, segmentY + eyeOffset1, eyeSize, 0, 2 * Math.PI);
                        ctx.fill();
                    } else { // Start
                        ctx.beginPath();
                        ctx.arc(segmentX + eyeOffset1, segmentY + eyeOffset1, eyeSize, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(segmentX + eyeOffset2, segmentY + eyeOffset1, eyeSize, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
            });
        }

        function getRandomFoodPosition() {
            let newFood;
            while (true) {
                newFood = {
                    x: Math.floor(Math.random() * tileCountX),
                    y: Math.floor(Math.random() * tileCountY)
                };

                let onSnake = false;
                for (const segment of snake) {
                    if (segment.x === newFood.x && segment.y === newFood.y) {
                        onSnake = true;
                        break;
                    }
                }

                // Also make sure food doesn't spawn on an obstacle
                let onObstacle = false;
                 for (const obs of obstacles) {
                    if (obs.x === newFood.x && obs.y === newFood.y) {
                        onObstacle = true;
                        break;
                    }
                }
                
                if (!onSnake && !onObstacle) {
                    break;
                }
            }
            return newFood;
        }

        function getRandomObstaclePosition() {
            let newObstacle;
            while (true) {
                newObstacle = {
                    x: Math.floor(Math.random() * tileCountX),
                    y: Math.floor(Math.random() * tileCountY)
                };

                // Check if on snake
                let onSnake = false;
                for (const segment of snake) {
                    if (segment.x === newObstacle.x && segment.y === newObstacle.y) {
                        onSnake = true;
                        break;
                    }
                }

                // Check if on food
                const onFood = (newObstacle.x === food.x && newObstacle.y === newObstacle.y);

                // Check if on *another* obstacle
                let onObstacle = false;
                for (const obs of obstacles) {
                    // --- BUG FIX 1 ---
                    // Was 'newObstlacle.y', now 'newObstacle.y'
                    if (obs.x === newObstacle.x && obs.y === newObstacle.y) {
                        onObstacle = true;
                        break;
                    }
                }

                if (!onSnake && !onFood && !onObstacle) {
                    break; // Found a valid spot
                }
            }
            return newObstacle; // Only returns {x, y}
        }

        // --- Decoy Food Helper Functions ---
        
        // We are no longer using this function, but it's safe to leave it.
        function clearDecoyObstacle() {
            // Remove any existing decoys
            obstacles = obstacles.filter(obs => obs.type !== 'decoy');
        }

        function spawnDecoyObstacle() {
            const newPos = getRandomObstaclePosition(); // This function already checks for valid spots
            obstacles.push({
                x: newPos.x,
                // --- BUG FIX 2 ---
                // Was 'newPos.row', now 'newPos.y'
                y: newPos.y, 
                lifetime: 999999, // 'permanent' (until game reset)
                type: 'decoy'
            });
        }

        function gameOver() {
            isGameOver = true;
            isGameRunning = false;
            saveHighScore();
            clearTimeout(gameLoopTimeout);
            
            gameOverMessage.style.opacity = '1';
            gameOverMessage.style.visibility = 'visible';
        }

        function restartGame() {
            snake = [{ x: 16, y: 9 }];
            direction = { x: 0, y: 0 };
            score = 0;
            gameSpeed = 150;
            isGameOver = false;
            isGameRunning = false;
            
            obstacles = []; // This clears rocks AND decoys
            spawnTimer = OBSTACLE_SPAWN_TICKS;
            
            food = getRandomFoodPosition(); // Set food *after* obstacles are cleared
            
            scoreBoard.textContent = `Score: ${score}`;
            gameOverMessage.style.opacity = '0';
            gameOverMessage.style.visibility = 'hidden';
            
            draw();
        }

        // --- Event Listeners ---
        function handleKeyDown(e) {
            if (!isGameRunning && e.key.includes('Arrow')) {
                if (!isGameOver) {
                    isGameRunning = true; 
                    gameLoop(); 
                }
            }

            if (isGameOver) {
                if (e.key === 'r' || e.key === 'R') {
                    restartGame();
                }
                return;
            }

            switch (e.key) {
                case 'ArrowUp':
                    if (direction.y === 0) {
                        direction = { x: 0, y: -1 };
                    }
                    break;
                case 'ArrowDown':
                    if (direction.y === 0) {
                        direction = { x: 0, y: 1 };
                    }
                    break;
                case 'ArrowLeft':
                    if (direction.x === 0) {
                        direction = { x: -1, y: 0 };
                    }
                    break;
                case 'ArrowRight':
                    if (direction.x === 0) {
                        direction = { x: 1, y: 0 };
                    }
                    break;
            }
        }

        document.addEventListener('keydown', handleKeyDown);

        // --- Initial Start ---
        loadHighScore();
        draw(); // Initial draw

    </script>
</body>
</html>